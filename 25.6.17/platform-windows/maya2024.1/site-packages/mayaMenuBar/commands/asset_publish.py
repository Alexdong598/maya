"""Asset publishing tool with Qt UI for Maya."""
import os
import sys
import importlib
import subprocess
import re
import maya.cmds as cmds
import maya.utils as utils
import maya.mel as mel
import maya.OpenMayaUI as omui
from PySide2 import QtWidgets, QtCore, QtUiTools
from PySide2.QtWidgets import QMainWindow, QMessageBox, QWidget
from shiboken2 import wrapInstance

def maya_main_window():
    """Get Maya's main window as a parent widget."""
    ptr = omui.MQtUtil.mainWindow()
    return wrapInstance(int(ptr), QWidget)

def load_ui(ui_file):
    """Load UI file with error handling"""
    loader = QtUiTools.QUiLoader()
    file = QtCore.QFile(ui_file)
    if not file.open(QtCore.QFile.ReadOnly):
        raise RuntimeError(f"Cannot open UI file: {ui_file} (check path)")
    ui = loader.load(file)
    file.close()
    return ui

class PublishToolWindow(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.resize(430, 946)
        self.setWindowTitle("Asset Publish Tool")

        # Load UI file
        script_dir = os.path.dirname(os.path.abspath(__file__))
        maya_menu_dir = os.path.dirname(script_dir)  # Go up to mayaMenuBar
        ui_file = os.path.join(maya_menu_dir, "QtWindows", "asset_publish_tool.ui")
        
        if not os.path.exists(ui_file):
            raise RuntimeError(f"UI file not found at: {ui_file}")
            
        self.ui = load_ui(ui_file)
        self.setCentralWidget(self.ui)

        # Set default publish options
        self.ui.USDCTag.setChecked(True)
        self.ui.AlembicTag.setChecked(True)
        
        # Connect menu actions
        self.ui.actionOpen_Project_Folder.triggered.connect(self.open_project_folder)
        self.ui.actionReset_Options.triggered.connect(self.reset_publish_options)

        # Connect all buttons
        self.ui.AboveToGridButton.clicked.connect(self.move_above_ground)
        self.ui.OriginalPivotButton.clicked.connect(self.original_pivot)
        self.ui.CleanHistoryButton.clicked.connect(self.clean_history_and_transform)
        self.ui.UnusedShadeButton.clicked.connect(self.remove_unused_shade)
        
        # Connect model check buttons
        from mayaMenuBar.utils.NgonAndManifold import execute as check_ngon_manifold
        self.ui.NgonAndManifold.clicked.connect(check_ngon_manifold)
        
        # Connect UV check buttons
        from mayaMenuBar.utils.checkUVOverlap import execute as check_uv_overlap
        from mayaMenuBar.utils.checkUVFlip import execute as check_uv_flip
        from mayaMenuBar.utils.UVCrossAndNegative import execute as check_uv_cross_negative
        from mayaMenuBar.utils.openHoudiniTool import execute as open_houdini
        
        self.ui.UVOverlap.clicked.connect(check_uv_overlap)
        self.ui.UVFlip.clicked.connect(check_uv_flip)
        self.ui.UVCross.clicked.connect(check_uv_cross_negative)
        self.ui.NameSpaceButton.clicked.connect(self.name_space_checking)
        self.ui.PublishInfoButton.clicked.connect(self.publish)
        self.ui.OpenHoudiniButton.clicked.connect(open_houdini)

    def open_project_folder(self):
        """Open Windows Explorer at specified project path"""
        HAL_TASK_ROOT = os.environ.get("HAL_TASK_ROOT", "")
        project_path = HAL_TASK_ROOT  # Update this path as needed
        try:
            subprocess.Popen(f'explorer "{project_path}"')
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open folder:\n{str(e)}")

    def reset_publish_options(self):
        """Reset publish options to default (USDC and Alembic checked)"""
        self.ui.USDCTag.setChecked(True)
        self.ui.USDATag.setChecked(False)
        self.ui.AlembicTag.setChecked(True)
        self.ui.OBJTag.setChecked(False)

    def original_pivot(self):
        selected = cmds.ls(sl=True)
        if not selected:
            cmds.warning("Please select top group")
            return
            
        processed = 0
        for top_obj in selected:
            all_objs = cmds.listRelatives(top_obj, allDescendents=True, fullPath=True) or []
            all_objs.append(top_obj)
            
            for obj in all_objs:
                if cmds.objectType(obj) == 'transform':
                    cmds.xform(obj, a=True, rp=(0, 0, 0), sp=(0, 0, 0), ws=True)
                    processed += 1
                    
        cmds.inViewMessage(
            msg=f"Pivot reset complete ({processed} objects)", 
            pos="topLeft", 
            fade=True
        )

    def clean_history_and_transform(self):
        selected = cmds.ls(sl=True)
        if not selected:
            cmds.warning("Please select top group")
            return
        for obj in selected:
            cmds.delete(constructionHistory=True)
            cmds.makeIdentity(obj, apply=True, translate=True, rotate=True, scale=True)
        cmds.inViewMessage(msg="History cleanup complete", pos="topLeft", fade=True)

    def remove_unused_shade(self):
        mel.eval('hyperShadePanelMenuCommand "hyperShadePanel1" "deleteUnusedNodes";')
        cmds.inViewMessage(msg="Unused shaders removed", pos="topLeft", fade=True)

    def move_above_ground(self):
        selected = cmds.ls(sl=True)
        if not selected or len(selected) > 1:
            cmds.warning("Please select exactly one top group")
            return
            
        top_obj = selected[0]
        
        try:
            bb = cmds.xform(top_obj, q=True, bb=True, ws=True)
            if not bb:
                raise RuntimeError("Could not get bounding box")
                
            center_x = (bb[0] + bb[3]) / 2
            center_z = (bb[2] + bb[5]) / 2
            
            current_x = cmds.getAttr(f"{top_obj}.translateX")
            current_z = cmds.getAttr(f"{top_obj}.translateZ")
            current_y = cmds.getAttr(f"{top_obj}.translateY")
            
            new_x = current_x - center_x
            new_z = current_z - center_z
            new_y = current_y - bb[1]
            
            cmds.setAttr(f"{top_obj}.translateX", new_x)
            cmds.setAttr(f"{top_obj}.translateZ", new_z)
            cmds.setAttr(f"{top_obj}.translateY", new_y)
            
            cmds.inViewMessage(
                msg=f"Centered {top_obj} (X:{center_x:.2f}, Z:{center_z:.2f}) and moved up by {-bb[1]:.2f} units", 
                pos="topLeft", 
                fade=True
            )
        except Exception as e:
            cmds.warning(f"Failed to adjust group position: {str(e)}")

    def name_space_checking(self):
        selected = cmds.ls(sl=True)
        if not selected:
            cmds.warning("Please select top group")
            return
            
        has_namespace = False
        for top_grp in selected:
            all_objs = cmds.listRelatives(top_grp, allDescendents=True, fullPath=True) or []
            all_objs.append(top_grp)
            for obj in all_objs:
                if ':' in obj:
                    has_namespace = True
                    break
            if has_namespace:
                break
                
        if not has_namespace:
            cmds.inViewMessage(msg="No namespaces found", pos="topLeft", fade=True)
            return
            
        cleaned = 0
        for obj in selected:
            if ':' in obj:
                _, _, clean_name = obj.rpartition(':')
                cmds.rename(obj, clean_name)
                cleaned += 1
                obj = clean_name
                
            children = cmds.listRelatives(obj, allDescendents=True, fullPath=True) or []
            for child in children:
                if ':' in child:
                    _, _, clean_child = child.rpartition(':')
                    cmds.rename(child, clean_child)
                    cleaned += 1
                    
        cmds.inViewMessage(msg=f"Cleaned {cleaned} namespaces", pos="topLeft", fade=True)

    def auto_save_scene(self):
        try:
            current_file = cmds.file(q=True, sn=True)
            if not current_file:
                cmds.file(rename="untitled.ma")
            cmds.file(save=True, type='mayaAscii')
            return True
        except Exception as e:
            cmds.error(f"Auto save failed: {str(e)}")
            return False

    def publish(self):
        if not self.auto_save_scene():
            return
            
        selected = cmds.ls(sl=True)
        if not selected:
            cmds.confirmDialog(
                title="Publish Warning",
                message="Please select top-level groups to publish!",
                button=["OK"],
                defaultButton="OK"
            )
            return

        for obj in selected:
            if not cmds.objectType(obj) == 'transform':
                cmds.confirmDialog(
                    title="Publish Warning",
                    message=f"Selected object '{obj}' is not a group (transform)",
                    button=["OK"],
                    defaultButton="OK"
                )
                return
            if cmds.listRelatives(obj, parent=True):
                cmds.confirmDialog(
                    title="Publish Warning",
                    message=f"Selected object '{obj}' is not top-level (has parent)",
                    button=["OK"],
                    defaultButton="OK"
                )
                return

        selected_formats = []
        if self.ui.USDCTag.isChecked():
            selected_formats.append("usdc")
        if self.ui.USDATag.isChecked():
            selected_formats.append("usda") 
        if self.ui.AlembicTag.isChecked():
            selected_formats.append("abc")
        if self.ui.OBJTag.isChecked():
            selected_formats.append("obj")

        if not selected_formats:
            cmds.warning("Please select at least one format")
            return

        try:
            next_version = self.get_next_version()
            for fmt in selected_formats:
                export_path = self.get_publish_path(fmt, next_version)
                self.export_file(fmt, export_path)
            
            cmds.confirmDialog(
                title="Publish Success",
                message=f"Published formats: {', '.join(selected_formats)}\nVersion: {next_version}",
                button=["OK"]
            )
        except Exception as e:
            cmds.error(f"Publish failed: {str(e)}")

    def get_next_version(self):
        publish_path = os.path.join(os.environ.get("HAL_TASK_ROOT", ""), "_publish")
        if not os.path.exists(publish_path):
            return "v001"

        files = [f for f in os.listdir(publish_path) 
                if os.path.isfile(os.path.join(publish_path, f))]

        version_pattern = re.compile(r'v(\d{3,})', re.IGNORECASE)
        max_version = 0

        for filename in files:
            base_name = os.path.splitext(filename)[0]
            match = version_pattern.search(base_name)
            if match:
                version_num = int(match.group(1))
                if version_num > max_version:
                    max_version = version_num

        next_version = max_version + 1
        return f"v{next_version:03d}"

    def get_publish_path(self, fmt, version):
        publish_folder = "_publish"
        HAL_ASSET = os.environ.get("HAL_ASSET", "")
        HAL_SEQUENCE = os.environ.get("HAL_SEQUENCE", "")
        HAL_SHOT = os.environ.get("HAL_SHOT", "")
        HAL_TASK = os.environ.get("HAL_TASK", "")
        HAL_TASK_ROOT = os.environ.get("HAL_TASK_ROOT", "")
        HAL_PROJECT_ABBR = os.environ.get("HAL_PROJECT_ABBR", "")
        HAL_USER_ABBR = os.environ.get("HAL_USER_ABBR", "")

        if not HAL_TASK_ROOT:
            raise RuntimeError("HAL_TASK_ROOT environment variable not set")

        path_segments = re.split(r"[\\/]", HAL_TASK_ROOT)
        if "_library" in path_segments:
            return os.path.join(
                HAL_TASK_ROOT,
                publish_folder,
                f"{HAL_PROJECT_ABBR}_{HAL_ASSET}_{HAL_TASK}_{version}_{HAL_USER_ABBR}.{fmt}"
            )
        else:
            return os.path.join(
                HAL_TASK_ROOT,
                publish_folder,
                f"{HAL_PROJECT_ABBR}_{HAL_SEQUENCE}_{HAL_SHOT}_{HAL_TASK}_{version}_{HAL_USER_ABBR}.{fmt}"
            )

    def export_file(self, fmt, path):
        if fmt == "usdc":
            cmds.mayaUSDExport(
                f=path,
                selection=True,
                defaultUSDFormat="usdc",
                # Use shadingMode="none" to prevent shading data on geometry
                shadingMode="none",
                # defaultMeshScheme works unless overridden by a Maya attribute
                defaultMeshScheme="none"
            )
        elif fmt == "usda":
            cmds.mayaUSDExport(
                f=path,
                selection=True,
                defaultUSDFormat="usda",
                # Use shadingMode="none" to prevent shading data on geometry
                shadingMode="none",
                # defaultMeshScheme works unless overridden by a Maya attribute
                defaultMeshScheme="none"
            )
        elif fmt == "abc":
            from mayaMenuBar.utils.exportABC import exportABC
            exportABC(path)
        elif fmt == "obj":
            cmds.file(path, force=True, options="groups=1;ptgroups=1;materials=1;smoothing=1;normals=1", 
                     type="OBJexport", exportSelected=True)

def get_command():
    def _command():
        importlib.reload(sys.modules[__name__])
        window = PublishToolWindow(parent=maya_main_window())
        window.show()
    return _command

def execute():
    importlib.reload(sys.modules[__name__])
    cmd = get_command()
    cmd()
