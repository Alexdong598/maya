"""Shader publishing tool with Qt UI for Maya."""
import os
import sys
import importlib
import subprocess
import re
import maya.cmds as cmds
import maya.utils as utils
import maya.mel as mel
import maya.OpenMayaUI as omui
from PySide2 import QtWidgets, QtCore, QtUiTools
from PySide2.QtWidgets import QMainWindow, QMessageBox, QWidget
from shiboken2 import wrapInstance

from ..utils import camThumbnail
from ..utils.SGlogin import ShotgunDataManager

import arnold

def maya_main_window():
    """Get Maya's main window as a parent widget."""
    ptr = omui.MQtUtil.mainWindow()
    return wrapInstance(int(ptr), QWidget)

def load_ui(ui_file):
    """Load UI file with error handling"""
    loader = QtUiTools.QUiLoader()
    file = QtCore.QFile(ui_file)
    if not file.open(QtCore.QFile.ReadOnly):
        raise RuntimeError(f"Cannot open UI file: {ui_file} (check path)")
    ui = loader.load(file)
    file.close()
    return ui

class PublishToolWindow(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.resize(480, 420)
        self.setWindowTitle("Shader Publish Tool")

        # Load UI file
        script_dir = os.path.dirname(os.path.abspath(__file__))
        maya_menu_dir = os.path.dirname(script_dir)  # Go up to mayaMenuBar
        ui_file = os.path.join(maya_menu_dir, "QtWindows", "shader_publish_tool.ui")
        
        if not os.path.exists(ui_file):
            raise RuntimeError(f"UI file not found at: {ui_file}")
            
        self.ui = load_ui(ui_file)
        self.setCentralWidget(self.ui)

        # Set default publish options
        self.ui.USDCTag.setChecked(True)
        self.ui.AlembicTag.setChecked(False)
        
        # Connect menu actions
        self.ui.actionOpen_Project_Folder.triggered.connect(self.open_project_folder)
        self.ui.actionReset_Options.triggered.connect(self.reset_publish_options)

        # Connect buttons
        from ..utils.openHoudiniTool import execute as open_houdini
        self.ui.NameSpaceButton.clicked.connect(self.name_space_checking)
        self.ui.PublishInfoButton.clicked.connect(self.publish)
        self.ui.OpenHoudiniButton.clicked.connect(open_houdini)

    def open_project_folder(self):
        """Open Windows Explorer at specified project path"""
        HAL_TASK_ROOT = os.environ.get("HAL_TASK_ROOT", "")
        project_path = HAL_TASK_ROOT
        try:
            subprocess.Popen(f'explorer "{project_path}"')
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open folder:\n{str(e)}")

    def reset_publish_options(self):
        """Reset publish options to default (USDC checked)"""
        self.ui.USDCTag.setChecked(True)
        self.ui.AlembicTag.setChecked(False)

    # Removed unused methods: original_pivot, clean_history_and_transform, 
    # remove_unused_shade, move_above_ground since they don't have UI buttons

    def name_space_checking(self):
        selected = cmds.ls(sl=True)
        if not selected or len(selected) > 1:
            cmds.warning("Please select exactly one top group")
            return
            
        top_obj = selected[0]
        
        try:
            bb = cmds.xform(top_obj, q=True, bb=True, ws=True)
            if not bb:
                raise RuntimeError("Could not get bounding box")
                
            center_x = (bb[0] + bb[3]) / 2
            center_z = (bb[2] + bb[5]) / 2
            
            current_x = cmds.getAttr(f"{top_obj}.translateX")
            current_z = cmds.getAttr(f"{top_obj}.translateZ")
            current_y = cmds.getAttr(f"{top_obj}.translateY")
            
            new_x = current_x - center_x
            new_z = current_z - center_z
            new_y = current_y - bb[1]
            
            cmds.setAttr(f"{top_obj}.translateX", new_x)
            cmds.setAttr(f"{top_obj}.translateZ", new_z)
            cmds.setAttr(f"{top_obj}.translateY", new_y)
            
            cmds.inViewMessage(
                msg=f"Centered {top_obj} and moved to ground.", 
                pos="topLeft", 
                fade=True
            )
        except Exception as e:
            cmds.warning(f"Failed to adjust group position: {str(e)}")

    def name_space_checking(self):
        selected = cmds.ls(sl=True)
        if not selected:
            cmds.warning("Please select top group")
            return
            
        has_namespace = False
        for top_grp in selected:
            all_objs = cmds.listRelatives(top_grp, allDescendents=True, fullPath=True) or []
            all_objs.append(top_grp)
            for obj in all_objs:
                if ':' in obj:
                    has_namespace = True
                    break
            if has_namespace:
                break
                
        if not has_namespace:
            cmds.inViewMessage(msg="No namespaces found", pos="topLeft", fade=True)
            return
            
        cleaned = 0
        for obj in selected:
            if ':' in obj:
                _, _, clean_name = obj.rpartition(':')
                cmds.rename(obj, clean_name)
                cleaned += 1
                obj = clean_name
                
            children = cmds.listRelatives(obj, allDescendents=True, fullPath=True) or []
            for child in children:
                if ':' in child:
                    _, _, clean_child = child.rpartition(':')
                    cmds.rename(child, clean_child)
                    cleaned += 1
                    
        cmds.inViewMessage(msg=f"Cleaned {cleaned} namespaces", pos="topLeft", fade=True)

    def auto_save_scene(self):
        try:
            current_file = cmds.file(q=True, sn=True)
            if not current_file:
                cmds.file(rename="untitled.ma")
            cmds.file(save=True, type='mayaAscii')
            return True
        except Exception as e:
            cmds.error(f"Auto save failed: {str(e)}")
            return False

    def publish(self):
        if not self.auto_save_scene():
            return
            
        # Store original selection to restore between exports
        original_selection = cmds.ls(sl=True, long=True)
        if not original_selection:
            QMessageBox.warning(self, "Publish Warning", "Please select top-level groups to publish!")
            return

        for obj in original_selection:
            if not cmds.objectType(obj) == 'transform':
                QMessageBox.warning(self, "Publish Warning", f"Selected object '{obj}' is not a group (transform)")
                return
            if cmds.listRelatives(obj, parent=True):
                QMessageBox.warning(self, "Publish Warning", f"Selected object '{obj}' is not top-level (has parent)")
                return

        selected_formats = []
        if self.ui.USDCTag.isChecked():
            selected_formats.append("usdc")
        if self.ui.AlembicTag.isChecked():
            selected_formats.append("abc")

        if not selected_formats:
            cmds.warning("Please select at least one format")
            return

        try:
            next_version = self.get_next_version()
            export_paths = []
            
            for fmt in selected_formats:
                # Restore original selection before each export
                cmds.select(original_selection, replace=True)
                export_path = self.get_publish_path(fmt, next_version)
                self.export_file(fmt, export_path)
                export_paths.append(export_path.replace(os.sep,"/"))
            
            # Submit all exported files to Shotgun at once
            self.submit_to_shotgun(export_paths)
            
            QMessageBox.information(
                self,
                "Publish Success", 
                f"Published formats: {', '.join(selected_formats)}\nVersion: {next_version}"
            )
        except Exception as e:
            QMessageBox.critical(self, "Publish Failed", f"Error during publish: {str(e)}")

    def get_next_version(self):
        publish_path = os.path.join(os.environ.get("HAL_TASK_ROOT", ""), "_publish")
        if not os.path.exists(publish_path):
            return "v001"

        files = [f for f in os.listdir(publish_path) 
                 if os.path.isfile(os.path.join(publish_path, f))]

        version_pattern = re.compile(r'v(\d{3,})', re.IGNORECASE)
        max_version = 0

        for filename in files:
            base_name = os.path.splitext(filename)[0]
            match = version_pattern.search(base_name)
            if match:
                version_num = int(match.group(1))
                if version_num > max_version:
                    max_version = version_num

        next_version = max_version + 1
        return f"v{next_version:03d}"

    def get_publish_path(self, fmt, version):
        publish_folder = "_publish"
        HAL_ASSET = os.environ.get("HAL_ASSET", "")
        HAL_SEQUENCE = os.environ.get("HAL_SEQUENCE", "")
        HAL_SHOT = os.environ.get("HAL_SHOT", "")
        HAL_TASK = os.environ.get("HAL_TASK", "")
        HAL_TASK_ROOT = os.environ.get("HAL_TASK_ROOT", "")
        HAL_PROJECT_ABBR = os.environ.get("HAL_PROJECT_ABBR", "")
        HAL_USER_ABBR = os.environ.get("HAL_USER_ABBR", "")

        if not HAL_TASK_ROOT:
            raise RuntimeError("HAL_TASK_ROOT environment variable not set")

        path_segments = re.split(r"[\\/]", HAL_TASK_ROOT)
        if "_library" in path_segments:
            return os.path.join(
                HAL_TASK_ROOT,
                publish_folder,
                f"{HAL_PROJECT_ABBR}_{HAL_ASSET}_{HAL_TASK}_{version}_{HAL_USER_ABBR}.{fmt}"
            )
        else:
            return os.path.join(
                HAL_TASK_ROOT,
                publish_folder,
                f"{HAL_PROJECT_ABBR}_{HAL_SEQUENCE}_{HAL_SHOT}_{HAL_TASK}_{version}_{HAL_USER_ABBR}.{fmt}"
            )

    def export_file(self, fmt, path):
        if fmt == "usdc":
            # Define the mask WITHOUT the filter node type
            clean_mask = (
                        # arnold.AI_NODE_OPTIONS | 
                        # arnold.AI_NODE_LIGHT | 
                        arnold.AI_NODE_SHAPE | 
                        arnold.AI_NODE_SHADER
                        )

            print(f"Using clean mask value: {clean_mask}") # This will print 45

            # Export using the clean mask and disabling fsh
            output = cmds.arnoldExportAss(
                f=path,
                selected=True,
                mask=clean_mask,         # Use the new mask that excludes filters
                fsh=False,               # Set to False for a cleaner export
                lightLinks=0,
                shadowLinks=0
            )

            print(f"Exported to: {path}")
        elif fmt == "abc":
            from ..utils.exportABC import export_abc
            current_frame = cmds.currentTime(q=True)
            export_abc(path, current_frame, current_frame)

    def submit_to_shotgun(self, asset_paths):
        """Submit all exported files to Shotgun with a single playblast"""
        if not isinstance(asset_paths, list):
            asset_paths = [asset_paths]
            
        # Get the first path for thumbnail naming
        first_path = asset_paths[0]
        try:
            camera = None
            print("\n=== Starting playblast submission process ===")
            
            print("Creating camera and framing objects...")
            camera = camThumbnail.frame_all_top_level_objects_in_maya(spin_offset=45, pitch_offset=-20)
            
            if not camera or not cmds.objExists(camera):
                raise RuntimeError(f"Failed to create or find camera: {camera}")
            print(f"Created camera: {camera}")

            HAL_TASK_ROOT = os.environ.get("HAL_TASK_ROOT", "")
            if not HAL_TASK_ROOT:
                cmds.warning("HAL_TASK_ROOT not set. Skipping playblast submission.")
                return

            basename = os.path.basename(first_path)
            version_match = re.search(r'v(\d{3,})', basename, re.IGNORECASE)
            version = version_match.group(0) if version_match else "v001"

            thumb_dir = os.path.join(HAL_TASK_ROOT, "_publish", "_SGthumbnail")
            os.makedirs(thumb_dir, exist_ok=True)
            
            thumb_name = os.path.splitext(basename)[0] + "_temp"
            thumb_path = os.path.join(thumb_dir, thumb_name).replace("\\", "/")
            
            cmds.lookThru(camera)

            cmds.playblast(
                filename=thumb_path,
                startTime=1001,
                endTime=1001,
                format='image',
                compression='png',
                quality=100,
                percent=100,
                widthHeight=(1920, 1080),
                showOrnaments=False,
                forceOverwrite=True,
                viewer=False,
                framePadding=4
            )
            
            final_path = thumb_path + ".1001.png"
            
            if not os.path.exists(final_path):
                raise RuntimeError(f"Playblast file was not created at {final_path}")
            
            print(f"Successfully created playblast at: {final_path}")

            print("Creating Shotgun version with thumbnail and all exported files...")
            sg_manager = ShotgunDataManager()
            # Convert paths list to string representation for Shotgun API
            publish_paths_str = "\n".join([p.replace(os.sep, "/") for p in asset_paths])
            sg_manager.Create_SG_Version(final_path, publish_paths_str)
            
        except Exception as e:
            QMessageBox.warning(self, "Playblast/Shotgun Error", f"Could not create/submit playblast:\n{e}")
        finally:
            # Cleanup the created camera
            cameras = cmds.ls("defaultFramedCamera*", type='transform')
            if cameras:
                cmds.delete(cameras)
            print("=== Playblast submission process completed ===")

def get_command():
    def _command():
        try:
            importlib.reload(sys.modules['mayaMenuBar.utils.camThumbnail'])
            importlib.reload(sys.modules[__name__])
        except Exception as e:
            print(f"Could not reload modules: {e}")
            
        window = PublishToolWindow(parent=maya_main_window())
        window.show()
    return _command

def execute():
    importlib.reload(sys.modules[__name__])
    cmd = get_command()
    cmd()
